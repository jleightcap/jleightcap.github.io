<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Jack Leightcap" />
  <title>Practical SAT: Solving Picross Puzzles</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../latex.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Practical SAT: Solving Picross Puzzles</h1>
<h2 class="author"><a href="../index.html">Jack Leightcap</a></h2>
<h3 class="date">June 5, 2020</h3>
</div>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<h2 id="abstract">Abstract</h2>
<p>Picross puzzles (also known as Nonograms) are a logic puzzle in the vein of Sudoku. A puzzle consists of a set of restrictions on each row and column of a grid:</p>
<center>
<img src="../Images/picross-wiki.svg" width="60%"> <a href="https://commons.wikimedia.org/w/index.php?curid=68386589">By Gus Polly at English Wikipedia - Own work, CC0</a>
</center>
<p>For a restriction like <code>[2 8]</code>, the slice with that restriction must contain 2 continuous cells, a separation gap of at least 1 cell, and 8 continuous cells; with any amount of padding on either end. These restrictions are the only information needed to uniquely encode this image! I think this is crazy, isn't this such a small amount of information needed to reconstruct this image? Maybe this could this be used for data compression! Well, probably not: as solving Picross puzzles has been proven NP-complete (Ueda, Nagao).</p>
<p>The solution being an array of Booleans, and solving being an NP-complete problem: I immediately thought about applying a SAT solver. A SAT solver is tailored to solve the <em>Boolean Satisfiability Problem</em> (<em>SAT</em> for short) as efficiently as possible: given a Boolean formula <span class="math inline"><em>F</em></span> like:</p>
<center>
<span class="math inline"><em>F</em> = (<em>a</em> ∨ ¬<em>b</em> ∨ <em>c</em>)∧(¬<em>a</em> ∨ <em>b</em> ∨ <em>c</em>)</span>
</center>
<p>can you set the input variables to be either true or false, such that the <span class="math inline"><em>F</em></span> is true? This may seem like a somewhat random problem, but this is the first known NP-complete problem (Cook, Levin), and there are many SAT solvers that are designed to find a set of input variables satisfying a given Boolean formula as effeciently as possible.</p>
<p>Here, I'll describe an algorithm to convert a Picross puzzle into an equivalent SAT problem. Using <code>MiniSat</code>, an off-the-shelf SAT solver with C++ integration, this allows for the solution for arbitrary puzzles with reasonable efficiency.</p>
<h2 id="example">Example</h2>
<p>Using an extremely simple puzzle as an example:</p>
<center>
<img src="../Images/picross-ex.png" width="20%">
</center>
<p>If you understand the rules of Picross, this is solvable almost at sight: however, this is a good example of the process used to encode a puzzle to an equivalent SAT problem.</p>
<p>Given the restriction <code>[1]</code> in a space of 2, there exists two possible permutations of cells: calling the state of these two cells <span class="math inline"><em>x</em></span> and <span class="math inline"><em>y</em></span>, the state of this slice <span class="math inline"><em>S</em></span> can be expressed as <span class="math inline"><em>S</em> = (<em>x</em> ∧ ¬<em>y</em>)∨(¬<em>x</em> ∧ <em>y</em>)</span>; if the restriction were <code>[2]</code> in the space of 2, <span class="math inline"><em>S</em></span> would just be <span class="math inline"><em>S</em> = <em>x</em> ∧ <em>y</em></span>.</p>
<p>These are the only two restrictions for the given example. For the whole board to be satisfied, all of the conditions of each slice must be satisfied:</p>
<center>
<br /><span class="math display">$$E =
\underbrace{[a \wedge b]}_{\text{row 1}}
\wedge
\underbrace{[(c \wedge \neg d) \vee (\neg c \wedge d)]}_{\text{row 2}}
\wedge
\underbrace{[a \wedge c]}_{\text{column 1}}
\wedge
\underbrace{[(b \wedge \neg d) \vee (\neg b \wedge d)]}_{\text{column 2}}$$</span><br />
</center>
<p>This expression sufficiently encodes the example as a Boolean formula. However, for reasons that will be explained later, SAT solvers expect an expression in the form of <code>AND</code> of <code>OR</code>s. This means slices like <span class="math inline">(<em>c</em> ∧ ¬<em>d</em>)∨(¬<em>c</em> ∧ <em>d</em>)</span> need to be rewritten, <span class="math inline">(<em>c</em> ∧ ¬<em>d</em>)∨(¬<em>c</em> ∧ <em>d</em>)=(<em>c</em> ∨ <em>d</em>)∧(¬<em>c</em> ∨ ¬<em>d</em>)</span>; And in total, a Boolean formula in the form a SAT solver would expect for <span class="math inline"><em>B</em></span>:</p>
<center>
<br /><span class="math display"><em>E</em> = <em>a</em> ∧ <em>b</em> ∧ (<em>c</em> ∨ <em>d</em>)∧(¬<em>c</em> ∨ ¬<em>d</em>)∧<em>a</em> ∧ <em>c</em> ∧ (<em>b</em> ∨ <em>d</em>)∧(¬<em>b</em> ∨ ¬<em>d</em>)</span><br />
</center>
<p>Testing using the <code>minisat</code> library in C++:</p>
<pre><code>#include &lt;minisat/core/Solver.h&gt;
#include &lt;iostream&gt;

int main() {
    using Minisat::mkLit;
    using Minisat::lbool;

    Minisat::Solver solver;

    auto A = solver.newVar();
    auto B = solver.newVar();
    auto C = solver.newVar();
    auto D = solver.newVar();

    solver.addClause(  mkLit(A)            );
    solver.addClause(  mkLit(B)            );
    solver.addClause(  mkLit(C),  mkLit(D) );
    solver.addClause( ~mkLit(C), ~mkLit(D) );
    solver.addClause(  mkLit(A)            );
    solver.addClause(  mkLit(C)            );
    solver.addClause(  mkLit(B),  mkLit(D) );
    solver.addClause( ~mkLit(B), ~mkLit(D) );

    auto sat = solver.solve();
    if (sat) {
        std::clog &lt;&lt; &quot;===SAT===\n&quot;;
        std::clog &lt;&lt; &quot;A=&quot; &lt;&lt; (solver.modelValue(A) == l_True) &lt;&lt; std::endl;
        std::clog &lt;&lt; &quot;B=&quot; &lt;&lt; (solver.modelValue(B) == l_True) &lt;&lt; std::endl;
        std::clog &lt;&lt; &quot;C=&quot; &lt;&lt; (solver.modelValue(C) == l_True) &lt;&lt; std::endl;
        std::clog &lt;&lt; &quot;D=&quot; &lt;&lt; (solver.modelValue(D) == l_True) &lt;&lt; std::endl;
        return 0;
    }
    else {
        std::clog &lt;&lt; &quot;===UNSAT===\n&quot;;
        return -1;
    }
}</code></pre>
<p>Gives the expected solution,</p>
<pre><code>===SAT===
A=1
B=1
C=1
D=0</code></pre>
<p>Great! This example is extremely simple, but shows all the steps that will be generalized.</p>
<h2 id="translation-algorithm">Translation Algorithm</h2>
<p>The translation algorithm of a Picross puzzle to an equivalent SAT problem has three distinct steps:</p>
<ol style="list-style-type: decimal">
<li>For a given slice, generate all permutations of white space vector for a given restriction vector.</li>
<li>Convert permutations of white space vector into DNF expression.</li>
<li>Convert set of slice DNF expressions into board CNF expression.</li>
</ol>
<h3 id="generating-slice-permutations">Generating Slice Permutations</h3>
<h4 id="defining-white-space-set-w">Defining White Space Set <span class="math inline"><em>W</em></span></h4>
<p>A given slice <span class="math inline"><em>S</em></span> consists of a size <span class="math inline"><em>n</em> = |<em>S</em>|</span> and a restriction set <span class="math inline"><em>R</em></span>. The goal of this step is to generate the set of valid permutations <span class="math inline"><em>P</em></span>.</p>
<p>For the given example, the permutations of the slices were small:</p>
<ul>
<li><span class="math inline"><em>n</em> = 2</span>, <span class="math inline"><em>R</em> = {1}</span>: <span class="math inline"><em>P</em> = {{1, 0},{0, 1}}</span>.</li>
<li><span class="math inline"><em>n</em> = 2</span>, <span class="math inline"><em>R</em> = {2}</span>: <span class="math inline"><em>P</em> = {{1, 1}}</span>.</li>
</ul>
<p>However, for a more complex example, <span class="math inline"><em>P</em></span> grows exponentially:</p>
<ul>
<li><span class="math inline"><em>n</em> = 6</span>, <span class="math inline"><em>R</em> = {1, 2}</span>: <span class="math inline"><em>P</em> = {{1, 0, 1, 1, 0, 0},{1, 0, 0, 1, 1, 0},{1, 0, 0, 0, 1, 1},...}</span></li>
</ul>
<p>To describe a valid slice <span class="math inline"><em>S</em><sub><em>v</em></sub> ∈ <em>P</em></span>, encode the lengths of white space and occupied cells. For example, one permutation for <span class="math inline"><em>n</em> = 6</span>, <span class="math inline"><em>R</em> = {1, 2}</span> is <span class="math inline"><em>S</em><sub><em>v</em></sub> = {1, 0, 1, 1, 0, 0}</span>; which can be encoded as <span class="math inline">|<em>S</em><sub><em>v</em></sub>|={1, 1, 2, 2}</span> (one 1, one 0, two 1s, two 0s). Generally, <span class="math inline">|<em>S</em><sub><em>v</em></sub>|</span> consists of:</p>
<center>
<br /><span class="math display">|<em>S</em><sub><em>v</em></sub>|={<em>W</em><sub>0</sub>, <em>R</em><sub>0</sub>, <em>W</em><sub>1</sub>, <em>R</em><sub>1</sub>, ..., <em>R</em><sub>|<em>R</em>|</sub>, <em>W</em><sub>|<em>R</em>|+1</sub>}</span><br />
</center>
<p>Where <span class="math inline"><em>R</em><sub><em>i</em></sub></span> is the <span class="math inline"><em>i</em></span>th element of <span class="math inline"><em>R</em></span>, and <span class="math inline"><em>W</em><sub><em>i</em></sub></span> is the <span class="math inline"><em>i</em></span>th element of the white space set <span class="math inline"><em>W</em></span>. <span class="math inline"><em>W</em></span> is described by the restrictions:</p>
<ul>
<li><span class="math inline">|<em>W</em>|=|<em>R</em>|+1</span> : there is one more white space cell than number of groups of cells (think of fenceposts).</li>
<li><span class="math inline">∑<em>W</em> = <em>n</em> − ∑<em>R</em></span>: the length of whole slice minus the total amount of occupied cells is the total amount of white space cells.</li>
<li><span class="math inline"><em>W</em><sub>0</sub> ≥ 0</span>, <span class="math inline"><em>W</em><sub>|<em>W</em>|</sub> ≥ 0</span>: there can be an arbitrary amount of padding on either end, including none.</li>
<li><span class="math inline"><em>W</em><sub>1..|<em>W</em>|−1</sub> &gt; 0</span>: there must be a separation of at least 1 between each group of cells.</li>
</ul>
<p>With this description, <span class="math inline"><em>S</em><sub><em>v</em></sub></span> can be reconstructed from <span class="math inline"><em>W</em></span> and the constant <span class="math inline"><em>R</em></span>, so generating <span class="math inline"><em>P</em></span> is equivalent to generating all valid permutations of <span class="math inline"><em>W</em></span>. Some simple examples of this encoding, where <span class="math inline"><em>n</em> = 6</span> and <span class="math inline"><em>R</em> = {2, 1}</span>:</p>
<ul>
<li><span class="math inline"><em>S</em><sub><em>v</em></sub> = {1, 1, 0, 0, 0, 1}</span>: <span class="math inline"><em>W</em> = {0, 3, 0}</span></li>
<li><span class="math inline"><em>S</em><sub><em>v</em></sub> = {0, 1, 1, 0, 0, 1}</span>: <span class="math inline"><em>W</em> = {1, 2, 0}</span></li>
<li><span class="math inline"><em>S</em><sub><em>v</em></sub> = {0, 1, 1, 0, 1, 0}</span>: <span class="math inline"><em>W</em> = {1, 1, 1}</span></li>
</ul>
<p>With this example, using the restrictions of <span class="math inline"><em>W</em></span>, you can even see what permutation was missed just by looking at <span class="math inline"><em>W</em></span>: <span class="math inline"><em>W</em> = {0, 2, 1}</span>.</p>
<h4 id="generating-permutations-of-w">Generating Permutations of <span class="math inline"><em>W</em></span></h4>
<p>For simplicity in generating permutations, defining <span class="math inline"><em>W</em>′</span>:</p>
<ul>
<li><span class="math inline">|<em>W</em>′| = |<em>R</em>|+1</span></li>
<li><span class="math inline">∑<em>W</em>′=<em>n</em> − ∑<em>R</em></span></li>
<li><span class="math inline"><em>W</em><sub>0..|<em>W</em>|</sub> ≥ 0</span></li>
</ul>
<p><span class="math inline"><em>W</em>′</span> is just <span class="math inline"><em>W</em></span> without the restriction that middle elements aren't zero. The relaxation from <span class="math inline"><em>W</em></span> to <span class="math inline"><em>W</em>′</span> means that all permutations of an element of <span class="math inline"><em>W</em>′</span> are still in <span class="math inline"><em>W</em>′</span>, which is not true of <span class="math inline"><em>W</em></span>. This allows for the simplification of just generating sets of strictly increasing values, then just generating all permutations of that set.</p>
<p>This problem can be restated with three parameters <span class="math inline"><em>n</em></span>, <span class="math inline"><em>h</em></span>, and <span class="math inline"><em>w</em></span>:</p>
<blockquote>
<p>Generate all combinations of sets of size at most <span class="math inline"><em>w</em></span>, where the sum of all elements is <span class="math inline"><em>n</em></span>, and all elements are between <span class="math inline">0</span> and <span class="math inline"><em>h</em></span>.</p>
</blockquote>
<p>Some examples:</p>
<ul>
<li><code>sumPermute(2,1,2)</code> returns <span class="math inline">{{1, 1}}</span></li>
<li><code>sumPermute(2,2,2)</code> returns <span class="math inline">{{2},{1, 1}}</span></li>
<li><code>sumPermute(4,3,3)</code> returns <span class="math inline">{{1, 3},{2, 2},{1, 1, 2}}</span></li>
</ul>
<p>This screams recursion to me! For the largest element, loop from the largest to smallest possible value as <code>i</code>, then prepend the result of <code>sumPermute(n - i, i, w - 1)</code>. This recursive relation shows the need to pass the <span class="math inline"><em>h</em></span> parameter such that elements are generated in strictly decreasing order.</p>
<p>To finish the recurrence relation, the minimum and maximum possible values and a base case are needed. The maximum value is simply <span class="math inline"><em>h</em></span>, and the minimum is <span class="math inline">ceil(<em>n</em>/<em>w</em>)</span> where the total number of cells is distributed equally across the entire width. The base case is <span class="math inline"><em>n</em> − <em>i</em> = 0</span>, where the remaining cells are all accounted for in the last cell. In total,</p>
<pre><code>sumPermute(n, h, w) {
    vector permute
    vector&lt;vector&gt; result

    for (i = ceil(n/w) → h) {
        permute.push(i)

        // reached base case
        if (n - i == 0) {
            result.push(permute);
            return result
        }

        permute.prepend(sumPermute(n - i, i, w - 1))
        result.push(permute)
    }
    return result
}</code></pre>
<p>This is best visualized as a recursion tree; using the example <code>sumPermute(4,3,3)</code>:</p>
<center>
<img src="../Images/picross-tree.png" width="90%">
</center>
<p>To generate <span class="math inline"><em>W</em></span>, filter elements of <span class="math inline"><em>W</em>′</span> where any of the middle elements are zero.</p>
<p>This completes the first step of the translation algorithm: converting a given slice into a set of permutations of the white space vector.</p>
<h3 id="converting-slice-permutations-to-dnf-expression">Converting Slice Permutations to DNF Expression</h3>
<p>At this point, for a given slice <span class="math inline"><em>S</em></span>, we have generated all valid permutations of <span class="math inline"><em>W</em></span>. To recover <span class="math inline"><em>P</em></span> the set of all valid slice permutations from each <span class="math inline"><em>W</em></span>, we do the encoding in 'reverse',</p>
<ul>
<li>push back <span class="math inline"><em>W</em><sub>0</sub></span> zeros</li>
<li>push back <span class="math inline"><em>R</em><sub>0</sub></span> ones</li>
<li>...</li>
<li>push back <span class="math inline"><em>R</em><sub>|<em>R</em>|</sub></span> ones</li>
<li>push back <span class="math inline"><em>W</em><sub>|<em>W</em>|</sub></span> zeros</li>
</ul>
<p>When repeated for each valid permutation of <span class="math inline"><em>W</em></span>, the resulting set is <span class="math inline"><em>P</em></span>.</p>
<p>To convert <span class="math inline"><em>P</em></span> to a set of Boolean expressions, an encoding of the board is needed. <code>MiniSat</code>'s literals are a wrapper around <code>int</code>s, so uniquely encoding each board cell as an integer using row-major ordering:</p>
<center>
<span class="math inline"><em>B</em><sub><em>x</em>, <em>y</em></sub> = <em>x</em> + dimX × <em>y</em></span>
</center>
<p>To convert each element of <span class="math inline"><em>P</em></span> to a corresponding Boolean expression, iterate over each permutation encoding <span class="math inline">¬<em>B</em><sub><em>i</em>, <em>j</em></sub></span> if a zero is read and <span class="math inline"><em>B</em><sub><em>i</em>, <em>j</em></sub></span> if a one is read. For one instance of a permutation, all of these literals are <code>AND</code>ed, and all permutations are <code>OR</code>ed for a resulting expression of every possibility for the given slice.</p>
<p>This final expression is in <em>Disjunctive Normal Form</em> (<code>OR</code> of <code>AND</code>s, or Sum of Products):</p>
<center>
<br /><span class="math display">$$\bigvee_{i=0}^m \left( \bigwedge_{j=0}^n B_{i,j} \right)$$</span><br />
</center>
<p>This completes the second step of the translation algorithm: converting a given slive into a DNF expression.</p>
<h3 id="converting-expressions-to-cnf">Converting Expressions to CNF</h3>
<p>At this point, we have a set of DNF expressions that satisfy each slice of the board. To satisfy the entire board, all of these expresssions must be satisfied: <code>AND</code>ing over all slices <span class="math inline"><em>S</em></span> gives a total expression for the board <span class="math inline"><em>E</em></span>:</p>
<center>
<br /><span class="math display">$$E = \bigwedge_{S} \left( \underbrace{\bigvee_{i=0}^m \left( \bigwedge_{j=0}^n B^S_{i,j} \right)}_{\text{DNF}} \right) $$</span><br />
</center>
<p>However, SAT solvers reasonably expect a standard form for input expressions. <em>Conjunctive Normal Form</em> is the form SAT solvers use to represent a Boolean formula (see <a href="https://cstheory.stackexchange.com/questions/1410/why-is-cnf-used-for-sat-and-not-dnf">this</a> thread for explanations as to why),</p>
<center>
<br /><span class="math display">$$\bigwedge_{i=0}^n \left( \bigvee_{j=0}^m x_{ij} \right)$$</span><br />
</center>
<p>So the final step of the translation algorithm is the conversion of <span class="math inline"><em>E</em></span> into CNF. Well, we're already pretty close with the outermost <code>AND</code>; in fact, just translating the inner DNF expression to CNF is sufficient,</p>
<center>
<br /><span class="math display">$$\bigwedge \left( \underbrace{\bigvee \left( \bigwedge x \right)}_{\text{DNF}} \right)
\hspace{1em} \rightarrow \hspace{1em}
\bigwedge \left( \underbrace{\bigwedge \left( \bigvee x \right)}_{\text{CNF}} \right)
\hspace{1em} = \hspace{1em}
\underbrace{\bigwedge \left( \bigvee x \right) }_{\text{CNF}}
$$</span><br />
</center>
<p>Converting DNF expressions to CNF expressions is another great exponential translation! I believe this algorithm is, formally speaking, <span class="math inline"><em>O</em>(bad)</span>. Using <span class="math inline"><em>a</em></span> as a shorthand for a sequence of <code>AND</code>ed literals, writing an expanded form of <span class="math inline"><em>E</em></span>:</p>
<center>
<span class="math inline"><em>E</em> = (<em>a</em><sub>11</sub> ∨ <em>a</em><sub>12</sub> ∨ ... ∨ <em>a</em><sub>1<em>n</em></sub>)∧(<em>a</em><sub>21</sub> ∨ <em>a</em><sub>22</sub> ∨ ... ∨ <em>a</em><sub>2<em>n</em></sub>)∧...∧(<em>a</em><sub><em>m</em>1</sub> ∨ <em>a</em><sub><em>m</em>2</sub> ∨ ... ∨ <em>a</em><sub><em>m</em><em>n</em></sub>)</span>
</center>
Converting to a CNF expression is once again making every permutation of sets. Using <span class="math inline"><em>E</em> = (<em>x</em><sub>11</sub> ∧ <em>x</em><sub>12</sub> ∧ <em>x</em><sub>13</sub>)∨(<em>x</em><sub>21</sub> ∧ <em>x</em><sub>22</sub> ∧ <em>x</em><sub>23</sub>)</span> as an example:
<center>
<br /><span class="math display">$$E = \begin{matrix}
(x_{11} \vee x_{21}) &amp; \wedge &amp; (x_{11} \vee x_{22}) &amp; \wedge &amp; (x_{11} \vee x_{23}) &amp; \wedge \\
(x_{12} \vee x_{21}) &amp; \wedge &amp; (x_{12} \vee x_{22}) &amp; \wedge &amp; (x_{12} \vee x_{23}) &amp; \wedge \\
(x_{13} \vee x_{21}) &amp; \wedge &amp; (x_{13} \vee x_{22}) &amp; \wedge &amp; (x_{13} \vee x_{23})
\end{matrix}$$</span><br />
</center>
<p>This is clearly very exponential, and the general form is quite large: using <span class="math inline">|<em>a</em>|=<em>l</em></span>,</p>
<center>
<br /><span class="math display">$$E = \begin{matrix}
(a_{111} \vee a_{211} \vee ... \vee a_{m11}) &amp; \wedge &amp; (a_{112} \vee a_{211} \vee ... \vee a_{m11}) &amp; \wedge &amp; ... &amp; \wedge &amp; (a_{11l} \vee a_{211} \vee ... \vee a_{m11}) &amp; \wedge \\
(a_{111} \vee a_{212} \vee ... \vee a_{m11}) &amp; \wedge &amp; (a_{112} \vee a_{212} \vee ... \vee a_{m11}) &amp; \wedge &amp; ... &amp; \wedge &amp; (a_{11l} \vee a_{212} \vee ... \vee a_{m11}) &amp; \wedge \\
\vdots &amp; &amp; \vdots &amp; &amp; \ddots &amp; &amp; \vdots \\
(a_{111} \vee a_{21l} \vee ... \vee a_{m11}) &amp; \wedge &amp; (a_{112} \vee a_{21l} \vee ... \vee a_{m11}) &amp; \wedge &amp; ... &amp; \wedge &amp; (a_{11l} \vee a_{21l} \vee ... \vee a_{m11}) &amp; \wedge \\
\vdots &amp; &amp; \vdots &amp; &amp; \ddots &amp; &amp; \vdots \\
(a_{111} \vee a_{21l} \vee ... \vee a_{m1l}) &amp; \wedge &amp; (a_{112} \vee a_{21l} \vee ... \vee a_{m1l}) &amp; \wedge &amp; ... &amp; \wedge &amp; (a_{11l} \vee a_{21l} \vee ... \vee a_{m1l}) &amp; \wedge \\
\vdots &amp; &amp; \vdots &amp; &amp; \ddots &amp; &amp; \vdots \\
(a_{1n1} \vee a_{2nl} \vee ... \vee a_{mnl}) &amp; \wedge &amp; (a_{1n2} \vee a_{2nl} \vee ... \vee a_{mnl}) &amp; \wedge &amp; ... &amp; \wedge &amp; (a_{1nl} \vee a_{2nl} \vee ... \vee a_{mnl})
\end{matrix}$$</span><br />
</center>
<p>The number of expressions grows as <span class="math inline"><em>O</em>(<em>l</em><sup><em>m</em></sup>)</span>... in other words, very bad! There are other general techniques for transforming DNF expressions to CNF expressions (see <a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form#Conversion_into_CNF">CNF Wikipedia page</a> for examples), however having a non-exponential growth requires a translation that is equisatisfiable but not equivalent. This could be useful if the question were instead <em>is there a solution</em> rather than <em>what is the solution</em>. With this final conversion, the translation algorithm is complete! Any Picross puzzle can be converted to an equivalent, SAT solver ready, CNF expression using this algorithm.</p>
<h2 id="implementation-considerations">Implementation, Considerations</h2>
<p>The complete code for <code>PicrossSAT</code> can be found <a href="https://github.com/jleightcap/PicrossSAT">here</a>.</p>
<p>In general, I didn't concern myself with the asymptotic complexity (in time or space) of each conversion. I assumed that the majority of the runtime would be consumed by the actual SAT solver, and not the conversion translation algorithm. This seems to be true for any puzzle larger than <span class="math inline">4 × 4</span>, at least from very basic testing.</p>
<p>This was my first program in 'modern' C++ after much more exposure to C, so please pardon the violations of best practices that I'm sure are there.</p>
</body>
</html>
