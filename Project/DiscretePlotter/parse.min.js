var Tokens;(function(Tokens){Tokens[Tokens["LPAREN"]=0]="LPAREN";Tokens[Tokens["RPAREN"]=1]="RPAREN";Tokens[Tokens["LIT_VAR"]=2]="LIT_VAR";Tokens[Tokens["LIT_INT"]=3]="LIT_INT";Tokens[Tokens["LIT_PI"]=4]="LIT_PI";Tokens[Tokens["LIT_E"]=5]="LIT_E";Tokens[Tokens["UNIOP_SIN"]=6]="UNIOP_SIN";Tokens[Tokens["UNIOP_COS"]=7]="UNIOP_COS";Tokens[Tokens["UNIOP_LN"]=8]="UNIOP_LN";Tokens[Tokens["BINOP_PLUS"]=9]="BINOP_PLUS";Tokens[Tokens["BINOP_MINUS"]=10]="BINOP_MINUS";Tokens[Tokens["BINOP_MUL"]=11]="BINOP_MUL";Tokens[Tokens["BINOP_DIV"]=12]="BINOP_DIV"})(Tokens||(Tokens={}));var Token_Map={"(":{type:Tokens.LPAREN},")":{type:Tokens.RPAREN},pi:{type:Tokens.LIT_PI,value:Math.PI},e:{type:Tokens.LIT_E,value:Math.E},sin:{type:Tokens.UNIOP_SIN},cos:{type:Tokens.UNIOP_COS},ln:{type:Tokens.UNIOP_LN},"+":{type:Tokens.BINOP_PLUS},"-":{type:Tokens.BINOP_MINUS},"*":{type:Tokens.BINOP_MUL},"/":{type:Tokens.BINOP_DIV}};function expression(s){var toks=tokenize(s);console.log(toks);var expr=parse(toks);return sexp_of_expr(expr)}function sexp_of_expr(exprs){if(exprs instanceof Array){var expr=exprs[0];var rest=exprs.slice(1);switch(expr.type){case"UNIOP_SIN":assert(rest.length==1,"sexp: `sin' expects one argument");var arg=function(x){return sexp_of_expr(rest[0])(x)};return function(x){return Math.sin(arg(x))};case"BINOP_PLUS":case"BINOP_MINUS":case"BINOP_MUL":case"BINOP_DIV":assert(rest.length==2,"sexp: binary function "+expr.type+" expects two arguments");var arg1=function(a1){return sexp_of_expr(rest[0])(a1)};var arg2=function(a2){return sexp_of_expr(rest[1])(a2)};switch(expr.type){case"BINOP_PLUS":return function(x){return arg1(x)+arg2(x)};case"BINOP_MINUS":return function(x){return arg1(x)-arg2(x)};case"BINOP_MUL":return function(x){return arg1(x)*arg2(x)};case"BINOP_DIV":return function(x){return arg1(x)/arg2(x)};default:assert(false,"sexp: unhandled binop")}}}else{switch(exprs.type){case"LIT_INT":case"LIT_PI":case"LIT_E":return function(_){return Number(exprs.value)};case"LIT_VAR":return function(x){return x}}}}function parse(toks){if(toks.length==0)return[];var tok=toks[0];var rest=toks.slice(1);switch(tok.type){case Tokens.LPAREN:var _a=parse_sublist(rest),sl=_a[0],tail=_a[1];assert(tail.length==0,"parse: unexpected extra tokens");return sl;case Tokens.LIT_INT|Tokens.LIT_VAR|Tokens.LIT_PI|Tokens.LIT_E:return tok;default:log("parse: unexpected token: "+toks[0].type)}}function parse_sublist(toks){var balance=1;var sublist=[];for(var ii=0;ii<toks.length;ii++){var tok=toks[ii];switch(toks[ii].type){case"LPAREN":var _a=parse_sublist(toks.slice(ii+1)),sl=_a[0],tail=_a[1];sublist.push(sl);ii+=sl.length;balance++;break;case"RPAREN":balance--;break;default:sublist.push(tok);break}}assert(balance==0,"parse: unbalanced parens");return[sublist,[]]}function tok_tag(lexeme){console.log(lexeme);if(/\d+|\d+.\d+/.test(lexeme)){return{type:Tokens.LIT_INT,value:+lexeme}}else if(lexeme in Token_Map){return Token_Map[lexeme]}else if(/\w+/.test(lexeme)){return{type:Tokens.LIT_VAR,name:lexeme}}else{assert(false,"tokenize: unexpected token "+lexeme)}}var re_tok=/\(|\)|\d+\.\d|\d+|\+|\-|\*|\/|sin|cos|ln|pi|e|\w+/g;function tokenize(s){s=s.trim();var _a=s.split("="),_=_a[0],def=_a[1];var toks=def.match(re_tok).map(tok_tag);return toks}function log(msg){var result=document.getElementById("parse_result");result.innerText=msg}function assert(cond,msg){if(!cond){log(msg)}else{log("")}}
