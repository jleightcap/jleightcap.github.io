var Tokens;(function(Tokens){Tokens[Tokens["LPAREN"]=0]="LPAREN";Tokens[Tokens["RPAREN"]=1]="RPAREN";Tokens[Tokens["LIT_VAR"]=2]="LIT_VAR";Tokens[Tokens["LIT_NUMBER"]=3]="LIT_NUMBER";Tokens[Tokens["UNIOP_SIN"]=4]="UNIOP_SIN";Tokens[Tokens["UNIOP_COS"]=5]="UNIOP_COS";Tokens[Tokens["UNIOP_LN"]=6]="UNIOP_LN";Tokens[Tokens["BINOP_PLUS"]=7]="BINOP_PLUS";Tokens[Tokens["BINOP_MINUS"]=8]="BINOP_MINUS";Tokens[Tokens["BINOP_MUL"]=9]="BINOP_MUL";Tokens[Tokens["BINOP_DIV"]=10]="BINOP_DIV"})(Tokens||(Tokens={}));var Token_Map={"(":{type:Tokens.LPAREN},")":{type:Tokens.RPAREN},pi:{type:Tokens.LIT_NUMBER,value:Math.PI},e:{type:Tokens.LIT_NUMBER,value:Math.E},sin:{type:Tokens.UNIOP_SIN},cos:{type:Tokens.UNIOP_COS},ln:{type:Tokens.UNIOP_LN},"+":{type:Tokens.BINOP_PLUS},"-":{type:Tokens.BINOP_MINUS},"*":{type:Tokens.BINOP_MUL},"/":{type:Tokens.BINOP_DIV}};function expression(s){var toks=tokenize(s);console.log("toks: ",toks);var expr=parse(toks);console.log("expr: ",expr);return lambda_expr(expr)}function lambda_expr(expr){console.log("lambda: ",expr);var ExprType;(function(ExprType){ExprType[ExprType["Var"]=0]="Var";ExprType[ExprType["Num"]=1]="Num";ExprType[ExprType["Exp"]=2]="Exp"})(ExprType||(ExprType={}));var exptype=function(e){if(typeof e==="string")return ExprType.Var;if(typeof e==="number")return ExprType.Num;if(e instanceof Array)return ExprType.Exp};var asexpr=function(t){if(t instanceof Array)return t;else switch(t.type){case Tokens.LIT_VAR:return t.name;case Tokens.LIT_NUMBER:return t.value}};switch(exptype(expr)){case ExprType.Var:return function(x){return x};case ExprType.Num:return function(_){return expr};case ExprType.Exp:var funcall=expr;var _a=[funcall[0],funcall.slice(1)],op=_a[0],args=_a[1];console.log("op: ",op,"args: ",args);var argfuns_1=args.map(function(t){return lambda_expr(asexpr(t))});switch(op.type){case Tokens.UNIOP_SIN:assert(argfuns_1.length==1,"lambda: `sin' expects one parameter");return function(x){return Math.sin(argfuns_1[0](x))};case Tokens.UNIOP_COS:assert(argfuns_1.length==1,"lambda: `cos' expects one parameter");return function(x){return parseFloat(Math.cos(argfuns_1[0](x)).toFixed(3))};case Tokens.UNIOP_LN:assert(argfuns_1.length==1,"lambda: `ln' expects one parameter");return function(x){return parseFloat(Math.log(argfuns_1[0](x)).toFixed(3))};case Tokens.BINOP_PLUS:var add_curry_1=function(f,g){return function(x){return f(x)+g(x)}};return function(x){return argfuns_1.reduce(add_curry_1,function(_){return 0})(x)};case Tokens.BINOP_MINUS:var sub_curry_1=function(f,g){return function(x){return f(x)-g(x)}};return function(x){return argfuns_1.reduce(sub_curry_1,function(_){return 0})(x)};case Tokens.BINOP_MUL:var times_curry_1=function(f,g){return function(x){return f(x)*g(x)}};return function(x){return argfuns_1.reduce(times_curry_1,function(_){return 1})(x)};case Tokens.BINOP_DIV:var divide_curry_1=function(f,g){return function(x){return f(x)/g(x)}};return function(x){return argfuns_1.reduce(divide_curry_1,function(_){return 1})(x)}}}}function parse(toks){if(toks.length==0)return null;var tok=toks[0];var rest=toks.slice(1);switch(tok.type){case Tokens.LPAREN:var _a=parse_sublist(rest),sl=_a[0],tail=_a[1];assert(tail.length==0,"parse: unexpected extra tokens");return sl;case Tokens.LIT_NUMBER:return tok.value;case Tokens.LIT_VAR:return tok.name;default:log("parse: unexpected token: "+toks[0].type)}}function parse_sublist(toks){var balance=1;var sublist=[];for(var ii=0;ii<toks.length;ii++){var tok=toks[ii];switch(toks[ii].type){case Tokens.LPAREN:var _a=parse_sublist(toks.slice(ii+1)),sl=_a[0],tail=_a[1];assert(tail.length==0,"parse: unexpected leftover tokens");sublist.push(sl);ii+=sl.length;balance++;break;case Tokens.RPAREN:balance--;break;default:sublist.push(tok);break}if(balance==0)return[sublist,toks.slice(ii)]}log("parse: unbalanced parens")}function tok_tag(lexeme){if(/\d+|\d+.\d+/.test(lexeme)){return{type:Tokens.LIT_NUMBER,value:+lexeme}}else if(lexeme in Token_Map){return Token_Map[lexeme]}else if(/\w+/.test(lexeme)){return{type:Tokens.LIT_VAR,name:lexeme}}else{log("tokenize: unexpected lexeme "+lexeme)}}var re_tok=/\(|\)|\d+\.\d|\d+|\+|\-|\*|\/|sin|cos|ln|pi|e|\w+/g;function tokenize(s){s=s.trim();var _a=s.split("="),_=_a[0],def=_a[1];var toks=def.match(re_tok).map(tok_tag);return toks}function log(msg){var result=document.getElementById("parse_result");result.innerText=msg}function assert(cond,msg){if(!cond){log(msg)}else{log("")}}
